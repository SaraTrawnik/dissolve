#!/usr/bin/ruby

	# for output
	class String

		def black;          "\e[30m#{self}\e[0m" end
		def red;            "\e[31m#{self}\e[0m" end
		def green;          "\e[32m#{self}\e[0m" end
		def brown;          "\e[33m#{self}\e[0m" end
		def blue;           "\e[34m#{self}\e[0m" end
		def magenta;        "\e[35m#{self}\e[0m" end
		def cyan;           "\e[36m#{self}\e[0m" end
		def gray;           "\e[37m#{self}\e[0m" end
	end

	# teh program
	class Dissolver

		attr_accessor :this

		## @brief		get goal file
		def self.goalfile filename = @this['goalname']

			#filename = filename || @this['goalname']
			"#{@this['datadir']}/#{filename}.dat"
		end

		## @brief 		load or init
		def self.goal_or_new filename

			return File.file?(filename) ? Marshal.load(File.read(filename)) : [neu('entry')]
		end

		## @brief      working in goal mode
		def self.goal input

			# goal mode
			case input

				when "list"

					# list goals
					Dir.entries(@this['datadir']).each do |file|

						if file[-4..file.length] == ".dat"

							p file
						end
					end

				else

					if input.length > 1

						require 'uri'
						# make & use new goal
						newgoal = URI.escape(input)

						p "using #{newgoal} instead of #{@this['goalname']}"
						@this['goalname'] = newgoal

						# set goal
						File.open "#{@this['datadir']}/goal", "w" do |f|
							f.write newgoal
							f.close
						end

						# initialize datfile
						@this['data'] = goal_or_new(goalfile)
						@this['update'] = true
					else

						# print out current goal
						p "Current goal is #{@this['goalname']}."
					end
			end
		end

		## @brief      working in problem mode
		def self.problem input

			instruction = input.scan(/\w+/).first

			case instruction

				when "list"

					problem_tree

				when "solved"

					if current == 0

						puts "Currently at entry point."
						return
					end

					# not yet	
					# audionotification 'ok.mp3'
					
					# note the solution
					solution = input.sub(instruction, '').strip
					if solution.length > 1

						@this['data'][current][4] = solution
					end

					# solve current problem
					@this['data'][current][3] = true
					
					# print out problems
					problem_tree

					@this['update'] = true
				else

					if input.length > 1

						# find existing
						existing = @this['data'].find_index{|entry| entry[2] == input}
						
						if existing != nil

							@this['data'][existing][3] = false
						else

							# make & use new problem
							@this['data'] << neu(input, current)
						end

						@this['update'] = true
					end
					
					# print out the list
					problem_tree
			end
		end

		## @brief		problem overview
		def self.problem_tree depth = 4

			ancestor = current
			depth = 4
			while depth > 0

				if @this['data'][ancestor]

					ancestor = @this['data'][ancestor].first || 0
				end

				depth -= 1
			end

			puts tree ancestor

		end

		## @brief      route user requests
		def self.route

			# parse user input
			instruction = ARGV[0]
			input = String.new

			if ARGV.count > 1
				
				input = ARGV[1..(ARGV.length - 1)].join ' '
			end

			# route user input
			case instruction

				when "goal"

					goal input

				when "goals"

					goal "list"

				when "problem"

					problem input

				when "problems"

					problem "list"

				when "-h", "--help", "help"

					# help
					puts File.read("./README.md")

				else

					puts "Undefined command #{instruction || 'whitespace'}, try --help to see a list of commands."
			end
		end

		## @brief      init
		def self.init

			setup
			route

			update # datfile
		end

		## @brief      create/load necessary data
		def self.setup

			@this =
			{
				"datadir" => "#{`echo $HOME`.chomp}/.config/chunks",
				"udpate" => false
			}

			# init data dir
			if !Dir.exist?(@this['datadir'])
				Dir.mkdir(@this['datadir'])
			end

			# init goalfile
			if !File.file?("#{@this['datadir']}/goal")
				File.open "#{@this['datadir']}/goal", "w" do |f|
					f.write "default"
					f.close
				end
			end

			# define program state
			@this['goalname'] = File.read("#{@this['datadir']}/goal")

			@this['data'] = goal_or_new(goalfile)
		end

		## @brief      save changes to datfile
		def self.update

			if @this['update']

				File.open goalfile, "w" do |f|
					f.write Marshal.dump(@this['data'])
					f.close
				end

				puts "Updated."
			end
		end

		## @brief      return current problem
		def self.current

			for i in (@this['data'].length - 1).downto(0)

				if @this['data'][i][3] == false

					return i
				end
			end
		end

		## @brief      build a problem
		def self.neu desc, parent = 0, time = Time.new.to_i, solved = false

			return [parent, time, desc, solved]
		end

		## @brief      build a tree-like output of the data
		def self.tree (origin, depth = 0, more = false)

			text = String.new
			children = @this['data'].select {|entry| entry[0] == origin && @this['data'].index(entry) != origin}.sort_by{|entry|entry[1]}

			spacer = ' '*((depth)*4)
			text << spacer

			graphic = more ? "├" : "└"

			solved = @this['data'][origin][3] ? "✓" : ""
			solution = @this['data'][origin][4] || ""

			prepared = "#{graphic}── #{@this['data'][origin][2]}#{solved} #{solution}\n"
			prepared = origin == current ? prepared.red : prepared
			text << prepared

			depth += 1
			for i in (0..children.count - 1)

				text << tree(@this['data'].index(children[i]), depth, (children.count > 1 && i != (children.count - 1)))
			end

			return text
		end

		def self.audionotification file

			['mpv', 'mplayer', 'vlc'].each do |program|

				if `which #{program}`.chomp.length > 0

					`#{program} #{file}`
					break
				end
			end
		end
	end

	Dissolver::init
